(()=>{"use strict";var r={d:(n,o)=>{for(var e in o)r.o(o,e)&&!r.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:o[e]})},o:(r,n)=>Object.prototype.hasOwnProperty.call(r,n),r:r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})}},n={};r.r(n),r.d(n,{default:()=>o});const o="attribute vec4 a_color;\r\nattribute vec2 a_normal;\r\nattribute vec2 a_position;\r\n\r\nuniform mat3 u_matrix;\r\nuniform float u_sqrtZoomRatio;\r\nuniform float u_correctionRatio;\r\n\r\nvarying vec4 v_color;\r\n\r\nconst float minThickness = 1.7;\r\nconst float bias = 255.0 / 254.0;\r\n\r\nvoid main() {\r\n  // The only different here with edge.vert.glsl is that we need to handle null\r\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\r\n  // on how it works:\r\n  float normalLength = length(a_normal);\r\n  vec2 unitNormal = a_normal / normalLength;\r\n  if (normalLength <= 0.0) unitNormal = a_normal;\r\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\r\n  float webGLThickness = pixelsThickness * u_correctionRatio;\r\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\r\n\r\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness, 1)).xy, 0, 1);\r\n\r\n  v_color = a_color;\r\n  v_color.a *= bias;\r\n}\r\n";module.exports=n})();