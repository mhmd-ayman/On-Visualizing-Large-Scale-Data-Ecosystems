(()=>{"use strict";var r={d:(o,t)=>{for(var e in t)r.o(t,e)&&!r.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:t[e]})},o:(r,o)=>Object.prototype.hasOwnProperty.call(r,o),r:r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})}},o={};r.r(o),r.d(o,{default:()=>t});const t="attribute vec2 a_position;\r\nattribute float a_size;\r\nattribute vec4 a_color;\r\n\r\nuniform float u_ratio;\r\nuniform float u_scale;\r\nuniform mat3 u_matrix;\r\n\r\nvarying vec4 v_color;\r\nvarying float v_border;\r\n\r\nconst float bias = 255.0 / 254.0;\r\n\r\nvoid main() {\r\n  gl_Position = vec4(\r\n    (u_matrix * vec3(a_position, 1)).xy,\r\n    0,\r\n    1\r\n  );\r\n\r\n  // Multiply the point size twice:\r\n  //  - x SCALING_RATIO to correct the canvas scaling\r\n  //  - x 2 to correct the formulae\r\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\r\n\r\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\r\n\r\n  // Extract the color:\r\n  v_color = a_color;\r\n  v_color.a *= bias;\r\n}\r\n";module.exports=o})();