(()=>{"use strict";var e={d:(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>o});const o='attribute vec4 a_color;\r\nattribute vec2 a_normal;\r\nattribute vec2 a_position;\r\n\r\nuniform mat3 u_matrix;\r\nuniform float u_sqrtZoomRatio;\r\nuniform float u_correctionRatio;\r\n\r\nvarying vec4 v_color;\r\nvarying vec2 v_normal;\r\nvarying float v_thickness;\r\n\r\nconst float minThickness = 1.7;\r\nconst float bias = 255.0 / 254.0;\r\n\r\nvoid main() {\r\n  float normalLength = length(a_normal);\r\n  vec2 unitNormal = a_normal / normalLength;\r\n\r\n  // We require edges to be at least `minThickness` pixels thick *on screen*\r\n  // (so we need to compensate the SQRT zoom ratio):\r\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\r\n\r\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\r\n  // referential (in a ([0, 1], [0, 1]) space), using our "magic" correction\r\n  // ratio:\r\n  float webGLThickness = pixelsThickness * u_correctionRatio;\r\n\r\n  // Finally, we adapt the edge thickness to the "SQRT rule" in sigma (so that\r\n  // items are not too big when zoomed in, and not too small when zoomed out).\r\n  // The exact computation should be `adapted = value * zoom / sqrt(zoom)`, but\r\n  // it\'s simpler like this:\r\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\r\n\r\n  // Here is the proper position of the vertex\r\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness, 1)).xy, 0, 1);\r\n\r\n  // For the fragment shader though, we need a thickness that takes the "magic"\r\n  // correction ratio into account (as in webGLThickness), but so that the\r\n  // antialiasint effect does not depend on the zoom level. So here\'s yet\r\n  // another thickness version:\r\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\r\n\r\n  v_normal = unitNormal;\r\n  v_color = a_color;\r\n  v_color.a *= bias;\r\n}\r\n';module.exports=n})();