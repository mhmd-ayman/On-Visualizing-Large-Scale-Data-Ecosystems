(()=>{"use strict";var r={d:(e,o)=>{for(var n in o)r.o(o,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:o[n]})},o:(r,e)=>Object.prototype.hasOwnProperty.call(r,e),r:r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})}},e={};r.r(e),r.d(e,{default:()=>o});const o="precision mediump float;\r\n\r\nvarying vec4 v_color;\r\nvarying float v_border;\r\nvarying vec4 v_texture;\r\n\r\nuniform sampler2D u_atlas;\r\n\r\nconst float radius = 0.5;\r\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\nvoid main(void) {\r\n  vec4 color;\r\n\r\n  if (v_texture.w > 0.0) {\r\n    vec4 texel = texture2D(u_atlas, v_texture.xy + gl_PointCoord * v_texture.zw, -1.0);\r\n    color = vec4(mix(v_color, texel, texel.a).rgb, max(texel.a, v_color.a));\r\n  } else {\r\n    color = v_color;\r\n  }\r\n\r\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\r\n  float dist = length(m);\r\n\r\n  if (dist < radius - v_border) {\r\n    gl_FragColor = color;\r\n  } else if (dist < radius) {\r\n    gl_FragColor = mix(transparent, color, (radius - dist) / v_border);\r\n  } else {\r\n    gl_FragColor = transparent;\r\n  }\r\n}\r\n";module.exports=e})();