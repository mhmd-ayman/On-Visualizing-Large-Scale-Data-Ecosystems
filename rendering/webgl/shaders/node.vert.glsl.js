(()=>{"use strict";var r={d:(o,t)=>{for(var n in t)r.o(t,n)&&!r.o(o,n)&&Object.defineProperty(o,n,{enumerable:!0,get:t[n]})},o:(r,o)=>Object.prototype.hasOwnProperty.call(r,o),r:r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})}},o={};r.r(o),r.d(o,{default:()=>t});const t="attribute vec2 a_position;\r\nattribute float a_size;\r\nattribute float a_angle;\r\nattribute vec4 a_color;\r\n\r\nuniform mat3 u_matrix;\r\nuniform float u_sqrtZoomRatio;\r\nuniform float u_correctionRatio;\r\n\r\nvarying vec4 v_color;\r\nvarying vec2 v_diffVector;\r\nvarying float v_radius;\r\nvarying float v_border;\r\n\r\nconst float bias = 255.0 / 254.0;\r\nconst float marginRatio = 1.05;\r\n\r\nvoid main() {\r\n  float size = a_size * u_correctionRatio * u_sqrtZoomRatio * 4.0;\r\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\r\n  vec2 position = a_position + diffVector * marginRatio;\r\n  gl_Position = vec4(\r\n    (u_matrix * vec3(position, 1)).xy,\r\n    0,\r\n    1\r\n  );\r\n\r\n  v_border = u_correctionRatio * u_sqrtZoomRatio * u_sqrtZoomRatio;\r\n  v_diffVector = diffVector;\r\n  v_radius = size / 2.0 / marginRatio;\r\n\r\n  v_color = a_color;\r\n  v_color.a *= bias;\r\n}\r\n";module.exports=o})();